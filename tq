[1mdiff --git a/src/edu/illinois/Matrix/MotifMatrix.java b/src/edu/illinois/Matrix/MotifMatrix.java[m
[1mindex 83171bd..fc9c0ee 100644[m
[1m--- a/src/edu/illinois/Matrix/MotifMatrix.java[m
[1m+++ b/src/edu/illinois/Matrix/MotifMatrix.java[m
[36m@@ -7,19 +7,35 @@[m [mimport java.util.Random;[m
 [m
 import static java.util.stream.IntStream.range;[m
 [m
[31m-/**[m
[31m- * Created by Jacob on 12/8/2016.[m
[31m- */[m
 public class MotifMatrix extends WeightMatrix {[m
 [m
[31m-    public MotifMatrix(double icpc, int ml) {[m
[31m-        initMotifMatrix(icpc, ml);[m
[32m+[m[32m    private int motifLength;[m
[32m+[m[32m    private double informationContentPerColumn;[m
[32m+[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Creates a countMatrix that may be sampled from where[m[41m [m
[32m+[m[32m     * columns have informationContentPerColumn information content[m
[32m+[m[32m     * and there are motifLength columns[m
[32m+[m[32m     * @param informationContentPerColumn, information content per column[m
[32m+[m[32m     * @param motifLength, number of columns[m
[32m+[m[32m     */[m
[32m+[m[32m    public MotifMatrix(double informationContentPerColumn, int motifLength) {[m
[32m+[m[32m        this.informationContentPerColumn = informationContentPerColumn;[m
[32m+[m[32m        this.motifLength = motifLength;[m
[32m+[m[32m        initMatrix();[m
[32m+[m[32m        rows = motifLength;[m
[32m+[m[32m        cols = 4;[m
     }[m
 [m
[31m-    private void initMotifMatrix(double icpc, int ml) {[m
[31m-        this.ml = ml;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Initializes the countMatrix then randomly[m
[32m+[m[32m     * chooses the probabilities based off of the[m
[32m+[m[32m     * information content per column[m
[32m+[m[32m     */[m
[32m+[m[32m    public void initMatrix() {[m
         initCountMatrix();[m
[31m-        range(0,ml).parallel().forEach(i -> stochasticGradientDescent(icpc, i));[m
[32m+[m[32m        final Random r = new Random();[m
[32m+[m[32m        range(0,motifLength).parallel().forEach(i -> stochasticGradientDescent(r, i));[m
     }[m
 [m
     /**[m
[36m@@ -33,13 +49,11 @@[m [mpublic class MotifMatrix extends WeightMatrix {[m
      *     surpassed through taking a step of size 1. If a step of size[m
      *     greater than 1 surpasses the threshold, then the[m
      *     epoch will be undone.[m
[31m-     * @param icpc, information content per column[m
      * @param idx, row index of motif to perform work on[m
      */[m
[31m-    private void stochasticGradientDescent(double icpc, int idx) {[m
[32m+[m[32m    private void stochasticGradientDescent(Random r, int idx) {[m
         int prevStep = countSum / 4 / 1000;[m
         int step = prevStep > 0 ? prevStep : 5;[m
[31m-        Random r = new Random();[m
         int[] row = countMatrix[idx];[m
         int incIdx = r.nextInt(4);[m
         double ic = Utils.calcInformationContent(countSum, row);[m
[36m@@ -47,7 +61,7 @@[m [mpublic class MotifMatrix extends WeightMatrix {[m
 [m
         int decIdx = incIdx;[m
         while(step > 0) {[m
[31m-            while (ic < icpc) {[m
[32m+[m[32m            while (ic < informationContentPerColumn) {[m
                 decIdx = pickDecrementIndex(row, incIdx, step);[m
                 if (decIdx == -1) {[m
                     prevStep = step;[m
[36m@@ -61,7 +75,7 @@[m [mpublic class MotifMatrix extends WeightMatrix {[m
             }[m
             prevStep = step;[m
             step = prevStep / 2;[m
[31m-            if(ic > icpc) {[m
[32m+[m[32m            if(ic > informationContentPerColumn) {[m
                 row[incIdx] -= step;[m
                 row[decIdx] += step;[m
             }[m
[36m@@ -73,14 +87,14 @@[m [mpublic class MotifMatrix extends WeightMatrix {[m
     /**[m
      * Picks the index in a row that may be decremented without going negative[m
      * @param row, row of counts[m
[31m-     * @param ti, target index that may not be decremented[m
[32m+[m[32m     * @param targetIdx, target index that may not be decremented[m
      * @param step, amount of decrement[m
      * @return index to decrement[m
      */[m
[31m-    private int pickDecrementIndex(int[] row, int ti, int step) {[m
[32m+[m[32m    private int pickDecrementIndex(int[] row, int targetIdx, int step) {[m
         ArrayList<Integer> acceptableIndices = new ArrayList<>();[m
         for(int i = 0; i < row.length; i++) {[m
[31m-            if(ti == i)[m
[32m+[m[32m            if(targetIdx == i)[m
                 continue;[m
             if(row[i] - step >= 0)[m
                 acceptableIndices.add(i);[m
[36m@@ -96,9 +110,26 @@[m [mpublic class MotifMatrix extends WeightMatrix {[m
      * Initializes the countMatrix with the countSum/4 value[m
      */[m
     public void initCountMatrix() {[m
[31m-        countMatrix = new int[ml][4];[m
[32m+[m[32m        countMatrix = new int[motifLength][4];[m
         int initCount = countSum / 4;[m
[31m-        range(0,ml).parallel().forEach(i ->[m
[32m+[m[32m        range(0,motifLength).parallel().forEach(i ->[m
                 range(0, 4).forEach(j -> countMatrix[i][j] = initCount));[m
     }[m
[32m+[m
[32m+[m[32m    /**[m
[32m+[m[32m     * Use the weights to randomly select a base ml times to form a sampled motif[m
[32m+[m[32m     * @return motif, String[m
[32m+[m[32m     */[m
[32m+[m[32m    public String sample(Random r) {[m
[32m+[m[32m        StringBuilder stringBuilder = new StringBuilder();[m
[32m+[m[32m        range(0,motifLength).forEach(i -> {[m
[32m+[m[32m            int randomWeight = r.nextInt(countSum);[m
[32m+[m[32m            int j = -1, k = 0;[m
[32m+[m[32m            do {[m
[32m+[m[32m                k += countMatrix[i][++j];[m
[32m+[m[32m            } while(k < randomWeight);[m
[32m+[m[32m            stringBuilder.append(Utils.ACGT[j]);[m
[32m+[m[32m        });[m
[32m+[m[32m        return stringBuilder.toString();[m
[32m+[m[32m    }[m
 }[m
[1mdiff --git a/src/edu/illinois/Matrix/WeightMatrix.java b/src/edu/illinois/Matrix/WeightMatrix.java[m
[1mindex 53ed837..92ec999 100644[m
[1m--- a/src/edu/illinois/Matrix/WeightMatrix.java[m
[1m+++ b/src/edu/illinois/Matrix/WeightMatrix.java[m
[36m@@ -1,40 +1,14 @@[m
 package edu.illinois.Matrix;[m
 [m
[31m-import edu.illinois.Utils;[m
[31m-[m
 import java.util.Arrays;[m
[31m-import java.util.Random;[m
 import java.util.stream.Collectors;[m
 [m
[31m-import static java.util.stream.IntStream.*;[m
[31m-[m
[31m-/**[m
[31m- * Created by jwtrueb on 11/18/16.[m
[31m- */[m
[31m-public class WeightMatrix {[m
[31m-    int ml;[m
[32m+[m[32mpublic abstract class WeightMatrix {[m
[32m+[m[32m    int rows, cols;[m
     int[][] countMatrix;[m
     int countSum = 1000000;[m
 [m
[31m-    public WeightMatrix() {}[m
[31m-[m
[31m-[m
[31m-    /**[m
[31m-     * Use the weights to randomly select a base ml times to form a sampled motif[m
[31m-     * @return motif, String[m
[31m-     */[m
[31m-    public String sample(Random r) {[m
[31m-        StringBuilder stringBuilder = new StringBuilder();[m
[31m-        range(0,ml).forEach(i -> {[m
[31m-            int randomWeight = r.nextInt(countSum);[m
[31m-            int j = -1, k = 0;[m
[31m-            do {[m
[31m-                k += countMatrix[i][++j];[m
[31m-            } while(k < randomWeight);[m
[31m-            stringBuilder.append(Utils.ACGT[j]);[m
[31m-        });[m
[31m-        return stringBuilder.toString();[m
[31m-    }[m
[32m+[m[32m    public abstract void initMatrix();[m
 [m
     @Override[m
     public String toString() {[m
[36m@@ -43,4 +17,20 @@[m [mpublic class WeightMatrix {[m
                 .map(b -> String.format("%d %d %d %d", b[0], b[1], b[2], b[3]))[m
                 .collect(Collectors.joining("\n"));[m
     }[m
[32m+[m
[32m+[m[32m    public int getRows() {[m
[32m+[m[32m        return rows;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    public void setRows(int rows) {[m
[32m+[m[32m        this.rows = rows;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    public int getCols() {[m
[32m+[m[32m        return cols;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    public void setCols(int cols) {[m
[32m+[m[32m        this.cols = cols;[m
[32m+[m[32m    }[m
 }[m
[1mdiff --git a/src/edu/illinois/Utils.java b/src/edu/illinois/Utils.java[m
[1mindex f1c54df..43c72c9 100644[m
[1m--- a/src/edu/illinois/Utils.java[m
[1m+++ b/src/edu/illinois/Utils.java[m
[36m@@ -77,7 +77,7 @@[m [mpublic class Utils {[m
         return weights.size() - 1;[m
     }[m
 [m
[31m-    static int indexOfBase(char base) {[m
[32m+[m[32m    public static int indexOfBase(char base) {[m
         switch(base) {[m
             case 'A': return 0;[m
             case 'C': return 1;[m
[1mdiff --git a/src/edu/illinois/finders/GibbsSampler.java b/src/edu/illinois/finders/GibbsSampler.java[m
[1mindex 8551245..b07e6c9 100644[m
[1m--- a/src/edu/illinois/finders/GibbsSampler.java[m
[1m+++ b/src/edu/illinois/finders/GibbsSampler.java[m
[36m@@ -44,7 +44,7 @@[m [mpublic class GibbsSampler extends MotifFinder {[m
         System.out.println("============= Input Sequences =============");[m
         sequences.stream().forEach(s -> System.out.println(s));[m
         System.out.println("============= Result of Gibbs Sampling Algorithm in each iteration =============");[m
[31m-        gibbsSample(maxIterations);[m
[32m+[m[32m        gibbsSample(new Random(), maxIterations);[m[41m[m
     }[m
 [m
     public void find() {[m
[36m@@ -206,39 +206,40 @@[m [mpublic class GibbsSampler extends MotifFinder {[m
      */[m
     public List<Integer> gibbsSample(Random r, int maxIterations){[m
         List<Integer> sites = getRandomSites(r);[m
[31m-        calculateQ();[m
[32m+[m[32m        Q = new SequenceMatrix(sequences);[m[41m[m
         int i = 0;[m
         while(i < maxIterations) {[m
             String z = predictiveUpdateStep(r, i);[m
             samplingStep(z);[m
         }[m
[31m-        // Predictive update step[m
[31m-        int chosenSeq;[m
[31m-        double maxQoverP;[m
[31m-        while(i > 0) {[m
[31m-            // randomly choose one sequence chosenSeq[m
[31m-            chosenSeq = rand.nextInt(seqSet.size());[m
[31m-            // recursively go through every subseq in chosenSeq and find max Q/P for each subSeq[m
[31m-            maxQoverP =  Double.MIN_VALUE;[m
[31m-            for ( int recSite = 0; recSite <= seqSet.get(0).length()- motifSize; recSite++ ) {[m
[31m-                // calculate Q[m
[31m-                // 1. gen PWM all choosen sites except chosSq[m
[31m-                // 2. get Log Q[m
[31m-                double q = genLogProbbyT( seqSet , chosenSeq, recSite , sites,  motifSize);[m
[31m-                // calculate P[m
[31m-                // Use background PWM => get Log P[m
[31m-                double p = LOG_25 * motifSize;[m
[31m-                // Log Q - Log P (Q/P) is largest then record it[m
[31m-                // replace the choosen motif sites of chosSq by the largest one[m
[31m-                if( q - p > maxQoverP){[m
[31m-                    sites.set(chosenSeq, recSite );[m
[31m-                    maxQoverP = q - p;[m
[31m-                }[m
[31m-            }[m
[31m-            i--;[m
[31m-        }[m
[31m-        return sites;[m
[31m-    }[m
[32m+[m[32m        return null;[m[41m[m
[32m+[m[32m//        // Predictive update step[m[41m[m
[32m+[m[32m//        int chosenSeq;[m[41m[m
[32m+[m[32m//        double maxQoverP;[m[41m[m
[32m+[m[32m//        while(i > 0) {[m[41m[m
[32m+[m[32m//            // randomly choose one sequence chosenSeq[m[41m[m
[32m+[m[32m//            chosenSeq = rand.nextInt(seqSet.size());[m[41m[m
[32m+[m[32m//            // recursively go through every subseq in chosenSeq and find max Q/P for each subSeq[m[41m[m
[32m+[m[32m//            maxQoverP =  Double.MIN_VALUE;[m[41m[m
[32m+[m[32m//            for ( int recSite = 0; recSite <= seqSet.get(0).length()- motifSize; recSite++ ) {[m[41m[m
[32m+[m[32m//                // calculate Q[m[41m[m
[32m+[m[32m//                // 1. gen PWM all choosen sites except chosSq[m[41m[m
[32m+[m[32m//                // 2. get Log Q[m[41m[m
[32m+[m[32m//                double q = genLogProbbyT( seqSet , chosenSeq, recSite , sites,  motifSize);[m[41m[m
[32m+[m[32m//                // calculate P[m[41m[m
[32m+[m[32m//                // Use background PWM => get Log P[m[41m[m
[32m+[m[32m//                double p = LOG_25 * motifSize;[m[41m[m
[32m+[m[32m//                // Log Q - Log P (Q/P) is largest then record it[m[41m[m
[32m+[m[32m//                // replace the choosen motif sites of chosSq by the largest one[m[41m[m
[32m+[m[32m//                if( q - p > maxQoverP){[m[41m[m
[32m+[m[32m//                    sites.set(chosenSeq, recSite );[m[41m[m
[32m+[m[32m//                    maxQoverP = q - p;[m[41m[m
[32m+[m[32m//                }[m[41m[m
[32m+[m[32m//            }[m[41m[m
[32m+[m[32m//            i--;[m[41m[m
[32m+[m[32m//        }[m[41m[m
[32m+[m[32m//        return sites;[m[41m[m
[32m+[m[32m//    }[m[41m[m
 [m
 [m
     /**[m
[1mdiff --git a/src/edu/illinois/tests/MotifMatrixTest.java b/src/edu/illinois/tests/MotifMatrixTest.java[m
[1mindex 0858700..a7494e7 100644[m
[1m--- a/src/edu/illinois/tests/MotifMatrixTest.java[m
[1m+++ b/src/edu/illinois/tests/MotifMatrixTest.java[m
[36m@@ -16,7 +16,7 @@[m [mpublic class MotifMatrixTest {[m
     @Test[m
     public void initCountMatrixTest() {[m
         MotifMatrix mm = new MotifMatrix(1.5, 10);[m
[31m-        mm.initCountMatrix(10);[m
[32m+[m[32m        mm.initCountMatrix();[m
         System.out.println(mm);[m
     }[m
 [m
